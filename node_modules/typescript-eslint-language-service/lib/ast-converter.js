"use strict";
// Note:
//
// Almost all line in this source file are copied from https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/typescript-estree/src/parser.ts ,
// This code is workaround for https://github.com/typescript-eslint/typescript-eslint/issues/774 .
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AstConverter = void 0;
const eslint_1 = require("eslint");
const scope_manager_1 = require("@typescript-eslint/scope-manager");
const visitor_keys_1 = require("@typescript-eslint/visitor-keys");
const globby_1 = require("globby");
const is_glob_1 = __importDefault(require("is-glob"));
const TsEstree = __importStar(require("@typescript-eslint/typescript-estree/dist/ast-converter"));
const shared_1 = require("@typescript-eslint/typescript-estree/dist/create-program/shared");
function validateBoolean(value, fallback = false) {
    if (typeof value !== "boolean") {
        return fallback;
    }
    return value;
}
function createExtra(code) {
    const base = {
        debugLevel: new Set(),
        tokens: null,
        range: true,
        loc: true,
        comment: false,
        comments: [],
        strict: false,
        jsx: false,
        log: () => { },
        programs: null,
        projects: [],
        errorOnUnknownASTType: false,
        errorOnTypeScriptSyntacticAndSemanticIssues: false,
        code: "",
        tsconfigRootDir: process.cwd(),
        extraFileExtensions: [],
        preserveNodeMaps: undefined,
        createDefaultProgram: false,
        filePath: "",
        EXPERIMENTAL_useSourceOfProjectReferenceRedirect: false,
        singleRun: false,
        moduleResolver: "",
    };
    return {
        ...base,
        code,
        tokens: [],
        loc: true,
        comment: true,
        comments: [],
    };
}
function getTsconfigPath(tsconfigPath, extra) {
    return (0, shared_1.getCanonicalFileName)((0, shared_1.ensureAbsolutePath)(tsconfigPath, extra));
}
/**
 * Normalizes, sanitizes, resolves and filters the provided project paths
 */
function prepareAndTransformProjects(extra, projectsInput, ignoreListInput) {
    const sanitizedProjects = [];
    // Normalize and sanitize the project paths
    if (typeof projectsInput === "string") {
        sanitizedProjects.push(projectsInput);
    }
    else if (Array.isArray(projectsInput)) {
        for (const project of projectsInput) {
            if (typeof project === "string") {
                sanitizedProjects.push(project);
            }
        }
    }
    if (sanitizedProjects.length === 0) {
        return [];
    }
    // Transform glob patterns into paths
    const nonGlobProjects = sanitizedProjects.filter(project => !(0, is_glob_1.default)(project));
    const globProjects = sanitizedProjects.filter(project => (0, is_glob_1.default)(project));
    const uniqueCanonicalProjectPaths = new Set(nonGlobProjects
        .concat((0, globby_1.sync)([...globProjects, ...ignoreListInput], {
        cwd: extra.tsconfigRootDir,
    }))
        .map(project => getTsconfigPath(project, extra)));
    // extra.log(
    //   'parserOptions.project (excluding ignored) matched projects: %s',
    //   uniqueCanonicalProjectPaths,
    // );
    return Array.from(uniqueCanonicalProjectPaths);
}
function applyParserOptionsToExtra(extra, options) {
    var _a;
    extra.range = typeof options.range === "boolean" ? options.range : extra.range;
    extra.loc = typeof options.loc === "boolean" ? options.loc : extra.range;
    /**
     * Track tokens in the AST
     */
    if (typeof options.tokens === "boolean" && options.tokens) {
        extra.tokens = [];
    }
    /**
     * Track comments in the AST
     */
    if (typeof options.comment === "boolean" && options.comment) {
        extra.comment = true;
        extra.comments = [];
    }
    /**
     * Enable JSX - note the applicable file extension is still required
     */
    if (typeof options.jsx === "boolean" && options.jsx) {
        extra.jsx = true;
    }
    /**
     * Allow the user to cause the parser to error if it encounters an unknown AST Node Type
     * (used in testing)
     */
    if (typeof options.errorOnUnknownASTType === "boolean" && options.errorOnUnknownASTType) {
        extra.errorOnUnknownASTType = true;
    }
    /**
     * Allow the user to override the function used for logging
     */
    if (typeof options.loggerFn === "function") {
        extra.log = options.loggerFn;
    }
    else if (options.loggerFn === false) {
        extra.log = Function.prototype;
    }
    if (typeof options.tsconfigRootDir === "string") {
        extra.tsconfigRootDir = options.tsconfigRootDir;
    }
    // NOTE - ensureAbsolutePath relies upon having the correct tsconfigRootDir in extra
    extra.filePath = (0, shared_1.ensureAbsolutePath)(extra.filePath, extra);
    if (Array.isArray(options.programs)) {
        if (options.programs.length) {
            extra.programs = options.programs;
        }
    }
    if (!extra.programs) {
        const projectFolderIgnoreList = ((_a = options.projectFolderIgnoreList) !== null && _a !== void 0 ? _a : ["**/node_modules/**"])
            .reduce((acc, folder) => {
            if (typeof folder === "string") {
                acc.push(folder);
            }
            return acc;
        }, [])
            // prefix with a ! for not match glob
            .map(folder => (folder.startsWith("!") ? folder : `!${folder}`));
        // NOTE - prepareAndTransformProjects relies upon having the correct tsconfigRootDir in extra
        extra.projects = prepareAndTransformProjects(extra, options.project, projectFolderIgnoreList);
    }
    if (Array.isArray(options.extraFileExtensions) && options.extraFileExtensions.every(ext => typeof ext === "string")) {
        extra.extraFileExtensions = options.extraFileExtensions;
    }
    /**
     * Allow the user to enable or disable the preservation of the AST node maps
     * during the conversion process.
     *
     * NOTE: For backwards compatibility we also preserve node maps in the case where `project` is set,
     * and `preserveNodeMaps` is not explicitly set to anything.
     */
    extra.preserveNodeMaps = typeof options.preserveNodeMaps === "boolean" && options.preserveNodeMaps;
    if (options.preserveNodeMaps === undefined && extra.projects.length > 0) {
        extra.preserveNodeMaps = true;
    }
    // extra.createDefaultProgram = typeof options.createDefaultProgram === "boolean" && options.createDefaultProgram;
    extra.EXPERIMENTAL_useSourceOfProjectReferenceRedirect =
        typeof options.EXPERIMENTAL_useSourceOfProjectReferenceRedirect === "boolean" &&
            options.EXPERIMENTAL_useSourceOfProjectReferenceRedirect;
    if (typeof options.moduleResolver === "string") {
        extra.moduleResolver = options.moduleResolver;
    }
    return extra;
}
class AstConverter {
    constructor({ getProgram }) {
        this.getProgram = getProgram;
    }
    /**
     *
     * see also https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/typescript-estree/src/parser.ts#L346
     *
     */
    parseAndGenerateServices(src, options) {
        const code = src.getFullText();
        let extra = createExtra(code);
        extra.code = code;
        /**
         * Apply the given parser options
         */
        if (typeof options !== "undefined") {
            extra = applyParserOptionsToExtra(extra, options);
            if (typeof options.errorOnTypeScriptSyntacticAndSemanticIssues === "boolean" &&
                options.errorOnTypeScriptSyntacticAndSemanticIssues) {
                extra.errorOnTypeScriptSyntacticAndSemanticIssues = true;
            }
        }
        const shouldProvideParserServices = extra.projects && extra.projects.length > 0;
        // Note: astConverter is an internal API
        const convert = TsEstree.astConverter;
        const { estree, astMaps } = convert(src, extra, true);
        /**
         * Return the converted AST and additional parser services
         */
        const ret = {
            ast: estree,
            services: {
                program: this.getProgram(),
                hasFullTypeInformation: shouldProvideParserServices,
                esTreeNodeToTSNodeMap: astMaps.esTreeNodeToTSNodeMap,
                tsNodeToESTreeNodeMap: astMaps.tsNodeToESTreeNodeMap,
            },
        };
        return ret;
    }
    /**
     * See also https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/parser/src/parser.ts
     */
    parseForESLint(src, options) {
        try {
            if (!options || typeof options !== "object") {
                options = {};
            }
            if (options.sourceType !== "module" && options.sourceType !== "script") {
                options.sourceType = "script";
            }
            if (typeof options.ecmaFeatures !== "object") {
                options.ecmaFeatures = {};
            }
            const parserOptions = {};
            Object.assign(parserOptions, options, {
                useJSXTextNode: validateBoolean(options.useJSXTextNode, true),
                jsx: validateBoolean(options.ecmaFeatures.jsx),
            });
            const analyzeOptions = {
                ecmaVersion: options.ecmaVersion,
                globalReturn: options.ecmaFeatures.globalReturn,
                jsxPragma: options.jsxPragma,
                jsxFragmentName: options.jsxFragmentName,
                lib: options.lib,
                sourceType: options.sourceType,
            };
            if (typeof options.filePath === "string") {
                const tsx = options.filePath.endsWith(".tsx");
                if (tsx || options.filePath.endsWith(".ts")) {
                    parserOptions.jsx = tsx;
                }
            }
            /**
             * Allow the user to suppress the warning from typescript-estree if they are using an unsupported
             * version of TypeScript
             */
            const warnOnUnsupportedTypeScriptVersion = validateBoolean(options.warnOnUnsupportedTypeScriptVersion, true);
            if (!warnOnUnsupportedTypeScriptVersion) {
                parserOptions.loggerFn = false;
            }
            const { ast, services } = this.parseAndGenerateServices(src, parserOptions);
            ast.sourceType = options.sourceType;
            const scopeManager = (0, scope_manager_1.analyze)(ast, analyzeOptions);
            return {
                ast: ast,
                scopeManager: scopeManager,
                services,
                visitorKeys: visitor_keys_1.visitorKeys,
            };
        }
        catch (error) {
            throw error;
        }
    }
    convertToESLintSourceCode(src, options) {
        const code = src.getFullText();
        const { ast, scopeManager, services, visitorKeys } = this.parseForESLint(src, options);
        return new eslint_1.SourceCode({
            text: code,
            ast,
            scopeManager,
            parserServices: services,
            visitorKeys,
        });
    }
}
exports.AstConverter = AstConverter;
//# sourceMappingURL=ast-converter.js.map